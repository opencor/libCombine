<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libCombine: CaBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libCombine
   </div>
   <div id="projectbrief">C++ library for working with the COMBINE Archive format</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_ca_base.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">CaBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>@sbmlbrief{} TODO:Definition of the <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;CaBase.h&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for CaBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="class_ca_base.png" usemap="#CaBase_map" alt=""/>
  <map id="CaBase_map" name="CaBase_map">
<area href="class_ca_content.html" title="@sbmlbrief{combine} TODO:Definition of the CaContent class." alt="CaContent" shape="rect" coords="0,56,119,80"/>
<area href="class_ca_cross_ref.html" title="@sbmlbrief{combine} TODO:Definition of the CaCrossRef class." alt="CaCrossRef" shape="rect" coords="129,56,248,80"/>
<area href="class_ca_list_of.html" alt="CaListOf" shape="rect" coords="258,56,377,80"/>
<area href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class." alt="CaOmexManifest" shape="rect" coords="387,56,506,80"/>
<area href="class_ca_list_of_contents.html" title="@sbmlbrief{combine} TODO:Definition of the CaListOfContents class." alt="CaListOfContents" shape="rect" coords="193,112,312,136"/>
<area href="class_ca_list_of_cross_refs.html" title="@sbmlbrief{combine} TODO:Definition of the CaListOfCrossRefs class." alt="CaListOfCrossRefs" shape="rect" coords="322,112,441,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99e70174646cbc74a3421ae281a1c851" id="r_a99e70174646cbc74a3421ae281a1c851"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99e70174646cbc74a3421ae281a1c851">~CaBase</a> ()</td></tr>
<tr class="memdesc:a99e70174646cbc74a3421ae281a1c851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object.  <br /></td></tr>
<tr class="separator:a99e70174646cbc74a3421ae281a1c851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205124bae0e46b48f83fc26d9f683f0c" id="r_a205124bae0e46b48f83fc26d9f683f0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ca_base.html">CaBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a205124bae0e46b48f83fc26d9f683f0c">operator=</a> (const <a class="el" href="class_ca_base.html">CaBase</a> &amp;rhs)</td></tr>
<tr class="memdesc:a205124bae0e46b48f83fc26d9f683f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a>.  <br /></td></tr>
<tr class="separator:a205124bae0e46b48f83fc26d9f683f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8647edfd0da8fdcfcb56b9f164451191" id="r_a8647edfd0da8fdcfcb56b9f164451191"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8647edfd0da8fdcfcb56b9f164451191">clone</a> () const =0</td></tr>
<tr class="memdesc:a8647edfd0da8fdcfcb56b9f164451191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a deep copy of this <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> object.  <br /></td></tr>
<tr class="separator:a8647edfd0da8fdcfcb56b9f164451191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463acd0dd36aab7718a5f3abff3a4280" id="r_a463acd0dd36aab7718a5f3abff3a4280"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a463acd0dd36aab7718a5f3abff3a4280">getElementBySId</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:a463acd0dd36aab7718a5f3abff3a4280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element it can find with a specific "id" attribute value, or <code>NULL</code> if no such object is found.  <br /></td></tr>
<tr class="separator:a463acd0dd36aab7718a5f3abff3a4280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7477aa240e7f879efb717b03d9e7df" id="r_ade7477aa240e7f879efb717b03d9e7df"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade7477aa240e7f879efb717b03d9e7df">getElementBySId</a> (const std::string &amp;metaid) const</td></tr>
<tr class="memdesc:ade7477aa240e7f879efb717b03d9e7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element it can find with a specific "id" attribute value, or <code>NULL</code> if no such object is found.  <br /></td></tr>
<tr class="separator:ade7477aa240e7f879efb717b03d9e7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0989c5898adf741c51e3b9a472dd7640" id="r_a0989c5898adf741c51e3b9a472dd7640"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0989c5898adf741c51e3b9a472dd7640">getElementByMetaId</a> (const std::string &amp;metaid)</td></tr>
<tr class="memdesc:a0989c5898adf741c51e3b9a472dd7640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found.  <br /></td></tr>
<tr class="separator:a0989c5898adf741c51e3b9a472dd7640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba99f7335133ed8aa3368c4fa6da875" id="r_a4ba99f7335133ed8aa3368c4fa6da875"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ba99f7335133ed8aa3368c4fa6da875">getElementByMetaId</a> (const std::string &amp;metaid) const</td></tr>
<tr class="memdesc:a4ba99f7335133ed8aa3368c4fa6da875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found.  <br /></td></tr>
<tr class="separator:a4ba99f7335133ed8aa3368c4fa6da875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad59b3c29661ddd4cc794a8b019749e" id="r_aaad59b3c29661ddd4cc794a8b019749e"><td class="memItemLeft" align="right" valign="top">virtual List *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad59b3c29661ddd4cc794a8b019749e">getAllElements</a> ()</td></tr>
<tr class="memdesc:aaad59b3c29661ddd4cc794a8b019749e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a List of all child <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> objects, including those nested to an arbitrary depth.  <br /></td></tr>
<tr class="separator:aaad59b3c29661ddd4cc794a8b019749e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c5b0b51f1e1b5f293680e7042380ea" id="r_a93c5b0b51f1e1b5f293680e7042380ea"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93c5b0b51f1e1b5f293680e7042380ea">getMetaId</a> () const</td></tr>
<tr class="memdesc:a93c5b0b51f1e1b5f293680e7042380ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "metaid" attribute of this object.  <br /></td></tr>
<tr class="separator:a93c5b0b51f1e1b5f293680e7042380ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0247ac232a6e731bb2a7ffdbad28daa" id="r_af0247ac232a6e731bb2a7ffdbad28daa"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0247ac232a6e731bb2a7ffdbad28daa">getMetaId</a> ()</td></tr>
<tr class="memdesc:af0247ac232a6e731bb2a7ffdbad28daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "metaid" attribute of this object.  <br /></td></tr>
<tr class="separator:af0247ac232a6e731bb2a7ffdbad28daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63a161de1c5435703b131ae156ae34" id="r_a9a63a161de1c5435703b131ae156ae34"><td class="memItemLeft" align="right" valign="top"><a id="a9a63a161de1c5435703b131ae156ae34" name="a9a63a161de1c5435703b131ae156ae34"></a>
virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getId</b> () const</td></tr>
<tr class="separator:a9a63a161de1c5435703b131ae156ae34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9269560de6836cad3df7a5ae3a973cc0" id="r_a9269560de6836cad3df7a5ae3a973cc0"><td class="memItemLeft" align="right" valign="top">LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9269560de6836cad3df7a5ae3a973cc0">getNotes</a> ()</td></tr>
<tr class="memdesc:a9269560de6836cad3df7a5ae3a973cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a tree of XMLNode objects.  <br /></td></tr>
<tr class="separator:a9269560de6836cad3df7a5ae3a973cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b966abd0bb4be17923430dc922156e" id="r_a91b966abd0bb4be17923430dc922156e"><td class="memItemLeft" align="right" valign="top">const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91b966abd0bb4be17923430dc922156e">getNotes</a> () const</td></tr>
<tr class="memdesc:a91b966abd0bb4be17923430dc922156e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a tree of XMLNode objects.  <br /></td></tr>
<tr class="separator:a91b966abd0bb4be17923430dc922156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fd5f551aba3eedb06ce605cd95c379" id="r_a23fd5f551aba3eedb06ce605cd95c379"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379">getNotesString</a> ()</td></tr>
<tr class="memdesc:a23fd5f551aba3eedb06ce605cd95c379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a string.  <br /></td></tr>
<tr class="separator:a23fd5f551aba3eedb06ce605cd95c379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbca9496462e61b3413914c273a2fc14" id="r_acbca9496462e61b3413914c273a2fc14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbca9496462e61b3413914c273a2fc14">getNotesString</a> () const</td></tr>
<tr class="memdesc:acbca9496462e61b3413914c273a2fc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a string.  <br /></td></tr>
<tr class="separator:acbca9496462e61b3413914c273a2fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3212ab33366f8cafc2e0fea6964b36" id="r_a4b3212ab33366f8cafc2e0fea6964b36"><td class="memItemLeft" align="right" valign="top">LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b3212ab33366f8cafc2e0fea6964b36">getAnnotation</a> ()</td></tr>
<tr class="memdesc:a4b3212ab33366f8cafc2e0fea6964b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a tree of XMLNode objects.  <br /></td></tr>
<tr class="separator:a4b3212ab33366f8cafc2e0fea6964b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242d2fb9bfaa83d269089f50c81d9798" id="r_a242d2fb9bfaa83d269089f50c81d9798"><td class="memItemLeft" align="right" valign="top">const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a242d2fb9bfaa83d269089f50c81d9798">getAnnotation</a> () const</td></tr>
<tr class="memdesc:a242d2fb9bfaa83d269089f50c81d9798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a tree of XMLNode objects.  <br /></td></tr>
<tr class="separator:a242d2fb9bfaa83d269089f50c81d9798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247f6e7caa0653b648c56c836da2a689" id="r_a247f6e7caa0653b648c56c836da2a689"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a247f6e7caa0653b648c56c836da2a689">getAnnotationString</a> ()</td></tr>
<tr class="memdesc:a247f6e7caa0653b648c56c836da2a689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a character string.  <br /></td></tr>
<tr class="separator:a247f6e7caa0653b648c56c836da2a689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd673c5060da13601a7e7587ce5eb26" id="r_a4fd673c5060da13601a7e7587ce5eb26"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fd673c5060da13601a7e7587ce5eb26">getAnnotationString</a> () const</td></tr>
<tr class="memdesc:a4fd673c5060da13601a7e7587ce5eb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a character string.  <br /></td></tr>
<tr class="separator:a4fd673c5060da13601a7e7587ce5eb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e3575171d01d305192fe9f3b981efe" id="r_a81e3575171d01d305192fe9f3b981efe"><td class="memItemLeft" align="right" valign="top">virtual const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNamespaces *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81e3575171d01d305192fe9f3b981efe">getNamespaces</a> () const</td></tr>
<tr class="memdesc:a81e3575171d01d305192fe9f3b981efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the XML Namespaces declared on the OMEX document owning this object.  <br /></td></tr>
<tr class="separator:a81e3575171d01d305192fe9f3b981efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af176d8e275582ff993bf6a112739d39d" id="r_af176d8e275582ff993bf6a112739d39d"><td class="memItemLeft" align="right" valign="top">virtual LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNamespaces *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af176d8e275582ff993bf6a112739d39d">getNamespaces</a> ()</td></tr>
<tr class="memdesc:af176d8e275582ff993bf6a112739d39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the XML Namespaces declared on the OMEX document owning this object.  <br /></td></tr>
<tr class="separator:af176d8e275582ff993bf6a112739d39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbbf58f920f8d644e3caaa6cc766a06" id="r_a8fbbf58f920f8d644e3caaa6cc766a06"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ca_omex_manifest.html">CaOmexManifest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fbbf58f920f8d644e3caaa6cc766a06">getCaOmexManifest</a> () const</td></tr>
<tr class="memdesc:a8fbbf58f920f8d644e3caaa6cc766a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object containing this object instance.  <br /></td></tr>
<tr class="separator:a8fbbf58f920f8d644e3caaa6cc766a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421d670badc6d0ad46387852bc8647b2" id="r_a421d670badc6d0ad46387852bc8647b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ca_omex_manifest.html">CaOmexManifest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a421d670badc6d0ad46387852bc8647b2">getCaOmexManifest</a> ()</td></tr>
<tr class="memdesc:a421d670badc6d0ad46387852bc8647b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object containing this object instance.  <br /></td></tr>
<tr class="separator:a421d670badc6d0ad46387852bc8647b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b10f85fbb84bca627e410ada88feb49" id="r_a6b10f85fbb84bca627e410ada88feb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b10f85fbb84bca627e410ada88feb49">getParentCaObject</a> ()</td></tr>
<tr class="memdesc:a6b10f85fbb84bca627e410ada88feb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent OMEX object containing this object.  <br /></td></tr>
<tr class="separator:a6b10f85fbb84bca627e410ada88feb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2218615791092a13838e4c1b149b433b" id="r_a2218615791092a13838e4c1b149b433b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2218615791092a13838e4c1b149b433b">getParentCaObject</a> () const</td></tr>
<tr class="memdesc:a2218615791092a13838e4c1b149b433b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent OMEX object containing this object.  <br /></td></tr>
<tr class="separator:a2218615791092a13838e4c1b149b433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f675b72247027993bf0d0c852aa4682" id="r_a7f675b72247027993bf0d0c852aa4682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f675b72247027993bf0d0c852aa4682">getAncestorOfType</a> (int type)</td></tr>
<tr class="memdesc:a7f675b72247027993bf0d0c852aa4682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first ancestor object that has the given OMEX type code.  <br /></td></tr>
<tr class="separator:a7f675b72247027993bf0d0c852aa4682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5010e5a8abad9f8157f9ff7a390e8c03" id="r_a5010e5a8abad9f8157f9ff7a390e8c03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ca_base.html">CaBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5010e5a8abad9f8157f9ff7a390e8c03">getAncestorOfType</a> (int type) const</td></tr>
<tr class="memdesc:a5010e5a8abad9f8157f9ff7a390e8c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first ancestor object that has the given OMEX type code.  <br /></td></tr>
<tr class="separator:a5010e5a8abad9f8157f9ff7a390e8c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c85593418e8f234b403e83b46d38696" id="r_a1c85593418e8f234b403e83b46d38696"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c85593418e8f234b403e83b46d38696">getLine</a> () const</td></tr>
<tr class="memdesc:a1c85593418e8f234b403e83b46d38696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number on which this object first appears in the XML representation of the OMEX document, or '0' if the object was created, not read from a file.  <br /></td></tr>
<tr class="separator:a1c85593418e8f234b403e83b46d38696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0638886f264d28fe50de399535e2719d" id="r_a0638886f264d28fe50de399535e2719d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0638886f264d28fe50de399535e2719d">getColumn</a> () const</td></tr>
<tr class="memdesc:a0638886f264d28fe50de399535e2719d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column number on which this object first appears in the XML representation of the OMEX document, or '0' if the object was created, not read from a file.  <br /></td></tr>
<tr class="separator:a0638886f264d28fe50de399535e2719d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa322d290c551024384e0e0556c21d414" id="r_aa322d290c551024384e0e0556c21d414"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa322d290c551024384e0e0556c21d414">isSetMetaId</a> () const</td></tr>
<tr class="memdesc:aa322d290c551024384e0e0556c21d414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "metaid" attribute is set.  <br /></td></tr>
<tr class="separator:aa322d290c551024384e0e0556c21d414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078875cee8659966e30707da11ec64cf" id="r_a078875cee8659966e30707da11ec64cf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a078875cee8659966e30707da11ec64cf">isSetId</a> () const</td></tr>
<tr class="memdesc:a078875cee8659966e30707da11ec64cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "id" attribute is set.  <br /></td></tr>
<tr class="separator:a078875cee8659966e30707da11ec64cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87ea24600cf7e32fa0739af86eb56de" id="r_aa87ea24600cf7e32fa0739af86eb56de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de">isSetNotes</a> () const</td></tr>
<tr class="memdesc:aa87ea24600cf7e32fa0739af86eb56de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "notes" subelement exists and has content.  <br /></td></tr>
<tr class="separator:aa87ea24600cf7e32fa0739af86eb56de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e63a6d1d8b343357064f733fc2c2744" id="r_a6e63a6d1d8b343357064f733fc2c2744"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744">isSetAnnotation</a> () const</td></tr>
<tr class="memdesc:a6e63a6d1d8b343357064f733fc2c2744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "annotation" subelement exists and has content.  <br /></td></tr>
<tr class="separator:a6e63a6d1d8b343357064f733fc2c2744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a8ffa5c220413f3a3f118143471a6a" id="r_a88a8ffa5c220413f3a3f118143471a6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a8ffa5c220413f3a3f118143471a6a">setMetaId</a> (const std::string &amp;metaid)</td></tr>
<tr class="memdesc:a88a8ffa5c220413f3a3f118143471a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the meta-identifier attribute of this object.  <br /></td></tr>
<tr class="separator:a88a8ffa5c220413f3a3f118143471a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2110e7aa28644b6a03a443e3e06c5ea3" id="r_a2110e7aa28644b6a03a443e3e06c5ea3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2110e7aa28644b6a03a443e3e06c5ea3">setId</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a2110e7aa28644b6a03a443e3e06c5ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "id" attribute of this OMEX object.  <br /></td></tr>
<tr class="separator:a2110e7aa28644b6a03a443e3e06c5ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ce2b36596260ccc47ea01487e060fd" id="r_a38ce2b36596260ccc47ea01487e060fd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38ce2b36596260ccc47ea01487e060fd">setAnnotation</a> (LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *annotation)</td></tr>
<tr class="memdesc:a38ce2b36596260ccc47ea01487e060fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "annotation" subelement of this OMEX object.  <br /></td></tr>
<tr class="separator:a38ce2b36596260ccc47ea01487e060fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729235cabf29ab0e203215ddc21e1a34" id="r_a729235cabf29ab0e203215ddc21e1a34"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a729235cabf29ab0e203215ddc21e1a34">setAnnotation</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a729235cabf29ab0e203215ddc21e1a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "annotation" subelement of this OMEX object.  <br /></td></tr>
<tr class="separator:a729235cabf29ab0e203215ddc21e1a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50251b9b15d113b6145b48137f07d0a4" id="r_a50251b9b15d113b6145b48137f07d0a4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50251b9b15d113b6145b48137f07d0a4">appendAnnotation</a> (const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *annotation)</td></tr>
<tr class="memdesc:a50251b9b15d113b6145b48137f07d0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>annotation</code> to the "annotation" subelement of this object.  <br /></td></tr>
<tr class="separator:a50251b9b15d113b6145b48137f07d0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b188422dafe049c6a611c515f18ce2f" id="r_a9b188422dafe049c6a611c515f18ce2f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b188422dafe049c6a611c515f18ce2f">appendAnnotation</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a9b188422dafe049c6a611c515f18ce2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>annotation</code> to the "annotation" subelement of this object.  <br /></td></tr>
<tr class="separator:a9b188422dafe049c6a611c515f18ce2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8eeefc12bd14f1e91dfff4bc4ff145" id="r_a2e8eeefc12bd14f1e91dfff4bc4ff145"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e8eeefc12bd14f1e91dfff4bc4ff145">removeTopLevelAnnotationElement</a> (const std::string elementName, const std::string elementURI=&quot;&quot;)</td></tr>
<tr class="memdesc:a2e8eeefc12bd14f1e91dfff4bc4ff145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the top-level element within the "annotation" subelement of this OMEX object with the given name and optional URI.  <br /></td></tr>
<tr class="separator:a2e8eeefc12bd14f1e91dfff4bc4ff145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacc112bb580a4b4c66bda4156ffcc28" id="r_aaacc112bb580a4b4c66bda4156ffcc28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaacc112bb580a4b4c66bda4156ffcc28">replaceTopLevelAnnotationElement</a> (const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *annotation)</td></tr>
<tr class="memdesc:aaacc112bb580a4b4c66bda4156ffcc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given top-level element within the "annotation" subelement of this OMEX object and with the annotation element supplied.  <br /></td></tr>
<tr class="separator:aaacc112bb580a4b4c66bda4156ffcc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969849ecd6cf03b9900e92f2cf64fd02" id="r_a969849ecd6cf03b9900e92f2cf64fd02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a969849ecd6cf03b9900e92f2cf64fd02">replaceTopLevelAnnotationElement</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a969849ecd6cf03b9900e92f2cf64fd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given top-level element within the "annotation" subelement of this OMEX object and with the annotation element supplied.  <br /></td></tr>
<tr class="separator:a969849ecd6cf03b9900e92f2cf64fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caedb0eee6fbd435658dc602d5447f7" id="r_a6caedb0eee6fbd435658dc602d5447f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6caedb0eee6fbd435658dc602d5447f7">setNotes</a> (const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *notes)</td></tr>
<tr class="memdesc:a6caedb0eee6fbd435658dc602d5447f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "notes" subelement of this OMEX object.  <br /></td></tr>
<tr class="separator:a6caedb0eee6fbd435658dc602d5447f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab84560444f3a86bd309fe3b3254224" id="r_a9ab84560444f3a86bd309fe3b3254224"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ab84560444f3a86bd309fe3b3254224">setNotes</a> (const std::string &amp;notes, bool addXHTMLMarkup=false)</td></tr>
<tr class="memdesc:a9ab84560444f3a86bd309fe3b3254224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "notes" subelement of this OMEX object to a copy of the string <code>notes</code>.  <br /></td></tr>
<tr class="separator:a9ab84560444f3a86bd309fe3b3254224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f56253254ec38725dd165f687ac852" id="r_a40f56253254ec38725dd165f687ac852"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40f56253254ec38725dd165f687ac852">appendNotes</a> (const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *notes)</td></tr>
<tr class="memdesc:a40f56253254ec38725dd165f687ac852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>notes</code> to the "notes" subelement of this object.  <br /></td></tr>
<tr class="separator:a40f56253254ec38725dd165f687ac852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d4c09ed628b621fe6e6beaf03d6e97" id="r_ac9d4c09ed628b621fe6e6beaf03d6e97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97">appendNotes</a> (const std::string &amp;notes)</td></tr>
<tr class="memdesc:ac9d4c09ed628b621fe6e6beaf03d6e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>notes</code> to the "notes" subelement of this object.  <br /></td></tr>
<tr class="separator:ac9d4c09ed628b621fe6e6beaf03d6e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a7966fa039844b4ea4e2870c72b7a7" id="r_ad7a7966fa039844b4ea4e2870c72b7a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7a7966fa039844b4ea4e2870c72b7a7">setNamespaces</a> (LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNamespaces *xmlns)</td></tr>
<tr class="memdesc:ad7a7966fa039844b4ea4e2870c72b7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the namespaces relevant of this OMEX object.  <br /></td></tr>
<tr class="separator:ad7a7966fa039844b4ea4e2870c72b7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71a8df29221b441acb3f38290e2396d" id="r_ae71a8df29221b441acb3f38290e2396d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae71a8df29221b441acb3f38290e2396d">unsetMetaId</a> ()</td></tr>
<tr class="memdesc:ae71a8df29221b441acb3f38290e2396d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "metaid" attribute of this OMEX object.  <br /></td></tr>
<tr class="separator:ae71a8df29221b441acb3f38290e2396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7c7b5927871ffcd287100f3b497364" id="r_abc7c7b5927871ffcd287100f3b497364"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc7c7b5927871ffcd287100f3b497364">unsetId</a> ()</td></tr>
<tr class="memdesc:abc7c7b5927871ffcd287100f3b497364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "id" attribute of this OMEX object.  <br /></td></tr>
<tr class="separator:abc7c7b5927871ffcd287100f3b497364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb468af2b83715d94f2be01c45d0183a" id="r_abb468af2b83715d94f2be01c45d0183a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb468af2b83715d94f2be01c45d0183a">unsetNotes</a> ()</td></tr>
<tr class="memdesc:abb468af2b83715d94f2be01c45d0183a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "notes" subelement of this OMEX object.  <br /></td></tr>
<tr class="separator:abb468af2b83715d94f2be01c45d0183a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465c67ba4ee9c529eba5d5f92e0e26ee" id="r_a465c67ba4ee9c529eba5d5f92e0e26ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee">unsetAnnotation</a> ()</td></tr>
<tr class="memdesc:a465c67ba4ee9c529eba5d5f92e0e26ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "annotation" subelement of this OMEX object.  <br /></td></tr>
<tr class="separator:a465c67ba4ee9c529eba5d5f92e0e26ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53397ff3a1230d24182e5a3079c1e60b" id="r_a53397ff3a1230d24182e5a3079c1e60b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53397ff3a1230d24182e5a3079c1e60b">getLevel</a> () const</td></tr>
<tr class="memdesc:a53397ff3a1230d24182e5a3079c1e60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the OMEX Level of the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object containing <em>this</em> object.  <br /></td></tr>
<tr class="separator:a53397ff3a1230d24182e5a3079c1e60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08020a804325d1c6e33bcf75eb7c035e" id="r_a08020a804325d1c6e33bcf75eb7c035e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08020a804325d1c6e33bcf75eb7c035e">getVersion</a> () const</td></tr>
<tr class="memdesc:a08020a804325d1c6e33bcf75eb7c035e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Version within the OMEX Level of the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object containing <em>this</em> object.  <br /></td></tr>
<tr class="separator:a08020a804325d1c6e33bcf75eb7c035e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91657399ab98a482e64f9e9d7951aa1b" id="r_a91657399ab98a482e64f9e9d7951aa1b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91657399ab98a482e64f9e9d7951aa1b">getTypeCode</a> () const</td></tr>
<tr class="separator:a91657399ab98a482e64f9e9d7951aa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4b26e062a2f6cbea2444856e7a9d51" id="r_a1a4b26e062a2f6cbea2444856e7a9d51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a4b26e062a2f6cbea2444856e7a9d51">hasValidLevelVersionNamespaceCombination</a> ()</td></tr>
<tr class="memdesc:a1a4b26e062a2f6cbea2444856e7a9d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's level/version and namespace values correspond to a valid OMEX specification.  <br /></td></tr>
<tr class="separator:a1a4b26e062a2f6cbea2444856e7a9d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4587e525d6090ed20433da5d7a568af0" id="r_a4587e525d6090ed20433da5d7a568af0"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4587e525d6090ed20433da5d7a568af0">getElementName</a> () const =0</td></tr>
<tr class="memdesc:a4587e525d6090ed20433da5d7a568af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML element name of this object.  <br /></td></tr>
<tr class="separator:a4587e525d6090ed20433da5d7a568af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b933a9ea9648f9246f0691b36a0f948" id="r_a7b933a9ea9648f9246f0691b36a0f948"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b933a9ea9648f9246f0691b36a0f948">toCa</a> ()</td></tr>
<tr class="memdesc:a7b933a9ea9648f9246f0691b36a0f948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string consisting of a partial OMEX corresponding to just this object.  <br /></td></tr>
<tr class="separator:a7b933a9ea9648f9246f0691b36a0f948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f50f3567cfd8eb175ce5b32db72bec3" id="r_a6f50f3567cfd8eb175ce5b32db72bec3"><td class="memItemLeft" align="right" valign="top"><a id="a6f50f3567cfd8eb175ce5b32db72bec3" name="a6f50f3567cfd8eb175ce5b32db72bec3"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSetAttribute</b> (const std::string &amp;attributeName) const</td></tr>
<tr class="separator:a6f50f3567cfd8eb175ce5b32db72bec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08c5ecd035ea5987a676c5c310efdda" id="r_af08c5ecd035ea5987a676c5c310efdda"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af08c5ecd035ea5987a676c5c310efdda">removeFromParentAndDelete</a> ()</td></tr>
<tr class="memdesc:af08c5ecd035ea5987a676c5c310efdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this object from its parent.  <br /></td></tr>
<tr class="separator:af08c5ecd035ea5987a676c5c310efdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c0195f0460a19feb4a2e2f44a4d7c6" id="r_a90c0195f0460a19feb4a2e2f44a4d7c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90c0195f0460a19feb4a2e2f44a4d7c6">matchesCaNamespaces</a> (const <a class="el" href="class_ca_base.html">CaBase</a> *sb)</td></tr>
<tr class="memdesc:a90c0195f0460a19feb4a2e2f44a4d7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces.  <br /></td></tr>
<tr class="separator:a90c0195f0460a19feb4a2e2f44a4d7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f83af6d42623b7c4fbad7454c91f4f9" id="r_a3f83af6d42623b7c4fbad7454c91f4f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f83af6d42623b7c4fbad7454c91f4f9">matchesCaNamespaces</a> (const <a class="el" href="class_ca_base.html">CaBase</a> *sb) const</td></tr>
<tr class="memdesc:a3f83af6d42623b7c4fbad7454c91f4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces.  <br /></td></tr>
<tr class="separator:a3f83af6d42623b7c4fbad7454c91f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07ef55d08303ba674b5557b224c5c59" id="r_ad07ef55d08303ba674b5557b224c5c59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad07ef55d08303ba674b5557b224c5c59">matchesRequiredCaNamespacesForAddition</a> (const <a class="el" href="class_ca_base.html">CaBase</a> *sb)</td></tr>
<tr class="memdesc:ad07ef55d08303ba674b5557b224c5c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces.  <br /></td></tr>
<tr class="separator:ad07ef55d08303ba674b5557b224c5c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0242529fa6143a50316e13c685bebd71" id="r_a0242529fa6143a50316e13c685bebd71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0242529fa6143a50316e13c685bebd71">matchesRequiredCaNamespacesForAddition</a> (const <a class="el" href="class_ca_base.html">CaBase</a> *sb) const</td></tr>
<tr class="memdesc:a0242529fa6143a50316e13c685bebd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces.  <br /></td></tr>
<tr class="separator:a0242529fa6143a50316e13c685bebd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1004ed4fc9be13ae92e4819cdda101d" id="r_af1004ed4fc9be13ae92e4819cdda101d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1004ed4fc9be13ae92e4819cdda101d">setUserData</a> (void *userData)</td></tr>
<tr class="memdesc:af1004ed4fc9be13ae92e4819cdda101d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the user data of this element.  <br /></td></tr>
<tr class="separator:af1004ed4fc9be13ae92e4819cdda101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c26b51594db9bc5ec9933fbbf874370" id="r_a6c26b51594db9bc5ec9933fbbf874370"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c26b51594db9bc5ec9933fbbf874370">getUserData</a> () const</td></tr>
<tr class="memdesc:a6c26b51594db9bc5ec9933fbbf874370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user data that has been previously set via <a class="el" href="#af1004ed4fc9be13ae92e4819cdda101d" title="Sets the user data of this element.">setUserData()</a>.  <br /></td></tr>
<tr class="separator:a6c26b51594db9bc5ec9933fbbf874370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a664853f0c8630587463fc94456355b" id="r_a5a664853f0c8630587463fc94456355b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a664853f0c8630587463fc94456355b">isSetUserData</a> () const</td></tr>
<tr class="memdesc:a5a664853f0c8630587463fc94456355b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning true or false depending on whether the user data of this element has been set.  <br /></td></tr>
<tr class="separator:a5a664853f0c8630587463fc94456355b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625227a7c609828531f0151545c46cf6" id="r_a625227a7c609828531f0151545c46cf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a625227a7c609828531f0151545c46cf6">unsetUserData</a> ()</td></tr>
<tr class="memdesc:a625227a7c609828531f0151545c46cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the user data of this element.  <br /></td></tr>
<tr class="separator:a625227a7c609828531f0151545c46cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcffa7ea28079c740dd3da7426069a3" id="r_a8bcffa7ea28079c740dd3da7426069a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ca_error_log.html">CaErrorLog</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bcffa7ea28079c740dd3da7426069a3">getErrorLog</a> ()</td></tr>
<tr class="memdesc:a8bcffa7ea28079c740dd3da7426069a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_ca_error_log.html" title="@sbmlbrief{} TODO:Definition of the CaErrorLog class.">CaErrorLog</a> used to log errors while reading and validating OMEX.  <br /></td></tr>
<tr class="separator:a8bcffa7ea28079c740dd3da7426069a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0b1c347d18393885b9331d098e654e99" id="r_a0b1c347d18393885b9331d098e654e99"><td class="memItemLeft" align="right" valign="top"><a id="a0b1c347d18393885b9331d098e654e99" name="a0b1c347d18393885b9331d098e654e99"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getHasBeenDeleted</b> () const</td></tr>
<tr class="separator:a0b1c347d18393885b9331d098e654e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75aefec7e7d0a027beb87d49a1f58cd" id="r_ae75aefec7e7d0a027beb87d49a1f58cd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae75aefec7e7d0a027beb87d49a1f58cd">setElementText</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:ae75aefec7e7d0a027beb87d49a1f58cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">When overridden allows <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> elements to use the text included in between the elements tags.  <br /></td></tr>
<tr class="separator:ae75aefec7e7d0a027beb87d49a1f58cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>@sbmlbrief{} TODO:Definition of the <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a99e70174646cbc74a3421ae281a1c851" name="a99e70174646cbc74a3421ae281a1c851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e70174646cbc74a3421ae281a1c851">&#9670;&#160;</a></span>~CaBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CaBase::~CaBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a50251b9b15d113b6145b48137f07d0a4" name="a50251b9b15d113b6145b48137f07d0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50251b9b15d113b6145b48137f07d0a4">&#9670;&#160;</a></span>appendAnnotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CaBase::appendAnnotation </td>
          <td>(</td>
          <td class="paramtype">const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *</td>          <td class="paramname"><span class="paramname"><em>annotation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given <code>annotation</code> to the "annotation" subelement of this object. </p>
<p>Whereas the <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<p>Unlike CaBase::setAnnotation(const XMLNode* annotation) or <a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">CaBase::setAnnotation(const std::string&amp; annotation)</a>, this method allows other annotations to be preserved when an application adds its own data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML structure that is to be copied and appended to the content of the "annotation" subelement of this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a247f6e7caa0653b648c56c836da2a689" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a9b188422dafe049c6a611c515f18ce2f" name="a9b188422dafe049c6a611c515f18ce2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b188422dafe049c6a611c515f18ce2f">&#9670;&#160;</a></span>appendAnnotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CaBase::appendAnnotation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>annotation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given <code>annotation</code> to the "annotation" subelement of this object. </p>
<p>Whereas the <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<p>Unlike CaBase::setAnnotation(const XMLNode* annotation) or <a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">CaBase::setAnnotation(const std::string&amp; annotation)</a>, this method allows other annotations to be preserved when an application adds its own data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML string that is to be copied and appended to the content of the "annotation" subelement of this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a247f6e7caa0653b648c56c836da2a689" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a40f56253254ec38725dd165f687ac852" name="a40f56253254ec38725dd165f687ac852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f56253254ec38725dd165f687ac852">&#9670;&#160;</a></span>appendNotes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::appendNotes </td>
          <td>(</td>
          <td class="paramtype">const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *</td>          <td class="paramname"><span class="paramname"><em>notes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given <code>notes</code> to the "notes" subelement of this object. </p>
<p>The content of <code>notes</code> is copied.</p>
<p>The optional OMEX element named "notes", present on every major OMEX component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libCombine provides the static utility method SyntaxChecker::hasExpectedXHTMLSyntax(  ); however, readers are urged to consult the appropriate <a href="http://omex.org/Documents/Specifications" target="_blank">OMEX specification document</a> for the Level and Version of their model for more in-depth explanations. The OMEX Level&#160;2 and &#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML node structure that is to appended to the content of the "notes" subelement of this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_INVALID_OBJECT </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#a9ab84560444f3a86bd309fe3b3254224" title="Sets the value of the &quot;notes&quot; subelement of this OMEX object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="ac9d4c09ed628b621fe6e6beaf03d6e97" name="ac9d4c09ed628b621fe6e6beaf03d6e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d4c09ed628b621fe6e6beaf03d6e97">&#9670;&#160;</a></span>appendNotes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::appendNotes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>notes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given <code>notes</code> to the "notes" subelement of this object. </p>
<p>The content of the parameter <code>notes</code> is copied.</p>
<p>The optional OMEX element named "notes", present on every major OMEX component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libCombine provides the static utility method SyntaxChecker::hasExpectedXHTMLSyntax(  ); however, readers are urged to consult the appropriate <a href="http://omex.org/Documents/Specifications" target="_blank">OMEX specification document</a> for the Level and Version of their model for more in-depth explanations. The OMEX Level&#160;2 and &#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML string that is to appended to the content of the "notes" subelement of this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_INVALID_OBJECT </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#a9ab84560444f3a86bd309fe3b3254224" title="Sets the value of the &quot;notes&quot; subelement of this OMEX object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="a8647edfd0da8fdcfcb56b9f164451191" name="a8647edfd0da8fdcfcb56b9f164451191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8647edfd0da8fdcfcb56b9f164451191">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ca_base.html">CaBase</a> * CaBase::clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a deep copy of this <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the (deep) copy of this <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> object. </dd></dl>

<p>Implemented in <a class="el" href="class_ca_content.html#a6a4b365c9ba0c9a1c3987fa489020850">CaContent</a>, <a class="el" href="class_ca_cross_ref.html#a385559fdeaab8f4dc4d1ed0bb25c94ba">CaCrossRef</a>, <a class="el" href="class_ca_list_of.html#a2f695331c105bd686f860171966906d8">CaListOf</a>, <a class="el" href="class_ca_list_of_contents.html#a61d10b80cda05fdc6bc9bf9731dcc8c7">CaListOfContents</a>, <a class="el" href="class_ca_list_of_cross_refs.html#ac7d18f400dad92808373698d16d044fa">CaListOfCrossRefs</a>, and <a class="el" href="class_ca_omex_manifest.html#ae113e452079826fe2c8edc5377b819b5">CaOmexManifest</a>.</p>

</div>
</div>
<a id="aaad59b3c29661ddd4cc794a8b019749e" name="aaad59b3c29661ddd4cc794a8b019749e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad59b3c29661ddd4cc794a8b019749e">&#9670;&#160;</a></span>getAllElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual List * CaBase::getAllElements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a List of all child <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> objects, including those nested to an arbitrary depth. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a List of pointers to all children objects. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ca_list_of.html#ac054325cde6d94c7f3685d7e3b8d0faa">CaListOf</a>.</p>

</div>
</div>
<a id="a7f675b72247027993bf0d0c852aa4682" name="a7f675b72247027993bf0d0c852aa4682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f675b72247027993bf0d0c852aa4682">&#9670;&#160;</a></span>getAncestorOfType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ca_base.html">CaBase</a> * CaBase::getAncestorOfType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first ancestor object that has the given OMEX type code. </p>
<p>This method searches the tree of objects that are parents of this object, and returns the first one that has the given OMEX type code from the given <code>pkgName</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the OMEX type code of the object sought</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ancestor OMEX object of this OMEX object that corresponds to the given  OMEX object type code  , or <code>NULL</code> if no ancestor exists. </dd></dl>

</div>
</div>
<a id="a5010e5a8abad9f8157f9ff7a390e8c03" name="a5010e5a8abad9f8157f9ff7a390e8c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5010e5a8abad9f8157f9ff7a390e8c03">&#9670;&#160;</a></span>getAncestorOfType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ca_base.html">CaBase</a> * CaBase::getAncestorOfType </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first ancestor object that has the given OMEX type code. </p>
<p>This method searches the tree of objects that are parents of this object, and returns the first one that has the given OMEX type code from the given <code>pkgName</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the OMEX type code of the object sought</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ancestor OMEX object of this OMEX object that corresponds to the given  OMEX object type code  , or <code>NULL</code> if no ancestor exists. </dd></dl>

</div>
</div>
<a id="a4b3212ab33366f8cafc2e0fea6964b36" name="a4b3212ab33366f8cafc2e0fea6964b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3212ab33366f8cafc2e0fea6964b36">&#9670;&#160;</a></span>getAnnotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode * CaBase::getAnnotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a tree of XMLNode objects. </p>
<p>The annotations returned by this method will be in XML form. LibCombine provides an object model and related interfaces for certain specific kinds of annotations, namely model history information and RDF content. See the ModelHistory, CVTerm and RDFAnnotationParser classes for more information about the facilities available.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this OMEX object as a tree of XMLNode objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a247f6e7caa0653b648c56c836da2a689" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a242d2fb9bfaa83d269089f50c81d9798" name="a242d2fb9bfaa83d269089f50c81d9798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242d2fb9bfaa83d269089f50c81d9798">&#9670;&#160;</a></span>getAnnotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode * CaBase::getAnnotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a tree of XMLNode objects. </p>
<p>The annotations returned by this method will be in XML form. LibCombine provides an object model and related interfaces for certain specific kinds of annotations, namely model history information and RDF content. See the ModelHistory, CVTerm and RDFAnnotationParser classes for more information about the facilities available.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this OMEX object as a tree of XMLNode objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a247f6e7caa0653b648c56c836da2a689" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a247f6e7caa0653b648c56c836da2a689" name="a247f6e7caa0653b648c56c836da2a689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247f6e7caa0653b648c56c836da2a689">&#9670;&#160;</a></span>getAnnotationString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CaBase::getAnnotationString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a character string. </p>
<p>The annotations returned by this method will be in string form. See the method <a class="el" href="#a4b3212ab33366f8cafc2e0fea6964b36" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> for a version that returns annotations in XML form.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this OMEX object as a character string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4b3212ab33366f8cafc2e0fea6964b36" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a4fd673c5060da13601a7e7587ce5eb26" name="a4fd673c5060da13601a7e7587ce5eb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd673c5060da13601a7e7587ce5eb26">&#9670;&#160;</a></span>getAnnotationString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CaBase::getAnnotationString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a character string. </p>
<p>The annotations returned by this method will be in string form. See the method <a class="el" href="#a4b3212ab33366f8cafc2e0fea6964b36" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> for a version that returns annotations in XML form.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this OMEX object as a character string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4b3212ab33366f8cafc2e0fea6964b36" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a421d670badc6d0ad46387852bc8647b2" name="a421d670badc6d0ad46387852bc8647b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421d670badc6d0ad46387852bc8647b2">&#9670;&#160;</a></span>getCaOmexManifest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ca_omex_manifest.html">CaOmexManifest</a> * CaBase::getCaOmexManifest </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object containing this object instance. </p>
<p>This method allows the caller to obtain the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> for the current object.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object of this OMEX object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6b10f85fbb84bca627e410ada88feb49" title="Returns the parent OMEX object containing this object.">getParentCaObject()</a> </dd>
<dd>
getModel() </dd></dl>

</div>
</div>
<a id="a8fbbf58f920f8d644e3caaa6cc766a06" name="a8fbbf58f920f8d644e3caaa6cc766a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbbf58f920f8d644e3caaa6cc766a06">&#9670;&#160;</a></span>getCaOmexManifest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ca_omex_manifest.html">CaOmexManifest</a> * CaBase::getCaOmexManifest </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object containing this object instance. </p>
<p>This method allows the caller to obtain the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> for the current object.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object of this OMEX object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6b10f85fbb84bca627e410ada88feb49" title="Returns the parent OMEX object containing this object.">getParentCaObject()</a> </dd>
<dd>
getModel() </dd></dl>

</div>
</div>
<a id="a0638886f264d28fe50de399535e2719d" name="a0638886f264d28fe50de399535e2719d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0638886f264d28fe50de399535e2719d">&#9670;&#160;</a></span>getColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int CaBase::getColumn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the column number on which this object first appears in the XML representation of the OMEX document, or '0' if the object was created, not read from a file. </p>
<dl class="section return"><dt>Returns</dt><dd>the column number of this OMEX object, or '0' if no such value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The column number for each construct in an OMEX model is set upon reading the model. The accuracy of the column number depends on the correctness of the XML representation of the model, and on the particular XML parser library being used. The former limitation relates to the following problem: if the model is actually invalid XML, then the parser may not be able to interpret the data correctly and consequently may not be able to establish the real column number. The latter limitation is simply that different parsers seem to have their own accuracy limitations, and out of all the parsers supported by libCombine, none have been 100% accurate in all situations. (At this time, libCombine supports the use of <a href="http://xmlsoft.org" target="_blank">libxml2</a>, <a href="http://expat.sourceforge.net/" target="_blank">Expat</a> and <a href="http://xerces.apache.org/xerces-c/" target="_blank">Xerces</a>.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1c85593418e8f234b403e83b46d38696" title="Returns the line number on which this object first appears in the XML representation of the OMEX docu...">getLine()</a> </dd></dl>

</div>
</div>
<a id="a0989c5898adf741c51e3b9a472dd7640" name="a0989c5898adf741c51e3b9a472dd7640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0989c5898adf741c51e3b9a472dd7640">&#9670;&#160;</a></span>getElementByMetaId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ca_base.html">CaBase</a> * CaBase::getElementByMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>metaid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>string representing the "metaid" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given meta-identifier. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ca_list_of.html#a2d4f15f3e35f3675f57b31304c48a78d">CaListOf</a>.</p>

</div>
</div>
<a id="a4ba99f7335133ed8aa3368c4fa6da875" name="a4ba99f7335133ed8aa3368c4fa6da875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba99f7335133ed8aa3368c4fa6da875">&#9670;&#160;</a></span>getElementByMetaId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ca_base.html">CaBase</a> * CaBase::getElementByMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>metaid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>string representing the "metaid" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given meta-identifier. </dd></dl>

</div>
</div>
<a id="a463acd0dd36aab7718a5f3abff3a4280" name="a463acd0dd36aab7718a5f3abff3a4280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463acd0dd36aab7718a5f3abff3a4280">&#9670;&#160;</a></span>getElementBySId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ca_base.html">CaBase</a> * CaBase::getElementBySId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element it can find with a specific "id" attribute value, or <code>NULL</code> if no such object is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>string representing the "id" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given identifier. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ca_content.html#a9667954a8b718c4726f5e93c271f6d0b">CaContent</a>, <a class="el" href="class_ca_list_of.html#ae58fdd1e25a422f430d6860f636be8d0">CaListOf</a>, and <a class="el" href="class_ca_omex_manifest.html#ae0178c56e3bc6efebd532b8eca2335ad">CaOmexManifest</a>.</p>

</div>
</div>
<a id="ade7477aa240e7f879efb717b03d9e7df" name="ade7477aa240e7f879efb717b03d9e7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7477aa240e7f879efb717b03d9e7df">&#9670;&#160;</a></span>getElementBySId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ca_base.html">CaBase</a> * CaBase::getElementBySId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>metaid</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element it can find with a specific "id" attribute value, or <code>NULL</code> if no such object is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>string representing the "id" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given identifier. </dd></dl>

</div>
</div>
<a id="a4587e525d6090ed20433da5d7a568af0" name="a4587e525d6090ed20433da5d7a568af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4587e525d6090ed20433da5d7a568af0">&#9670;&#160;</a></span>getElementName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string &amp; CaBase::getElementName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML element name of this object. </p>
<p>This is overridden by subclasses to return a string appropriate to the OMEX component. For example, Model defines it as returning <code>"model"</code>, CompartmentType defines it as returning <code>"compartmentType"</code>, and so on. </p>

<p>Implemented in <a class="el" href="class_ca_content.html#aaa14807b6264ee2756554362efd35d33">CaContent</a>, <a class="el" href="class_ca_cross_ref.html#abf9ac655f022475b38df2dbb674e678b">CaCrossRef</a>, <a class="el" href="class_ca_list_of.html#acf7e63a2d0bbb74d2f39a69142dcc715">CaListOf</a>, <a class="el" href="class_ca_list_of_contents.html#abdaa7e56851e7ab63292c98203efc2b9">CaListOfContents</a>, <a class="el" href="class_ca_list_of_cross_refs.html#a15a75fa11ad840fffb3acbfeaa400bb7">CaListOfCrossRefs</a>, and <a class="el" href="class_ca_omex_manifest.html#a3d8c176c987512f62d229f7d2ceb89b0">CaOmexManifest</a>.</p>

</div>
</div>
<a id="a8bcffa7ea28079c740dd3da7426069a3" name="a8bcffa7ea28079c740dd3da7426069a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcffa7ea28079c740dd3da7426069a3">&#9670;&#160;</a></span>getErrorLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ca_error_log.html">CaErrorLog</a> * CaBase::getErrorLog </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_ca_error_log.html" title="@sbmlbrief{} TODO:Definition of the CaErrorLog class.">CaErrorLog</a> used to log errors while reading and validating OMEX. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_ca_error_log.html" title="@sbmlbrief{} TODO:Definition of the CaErrorLog class.">CaErrorLog</a> used to log errors while reading and validating OMEX. </dd></dl>

</div>
</div>
<a id="a53397ff3a1230d24182e5a3079c1e60b" name="a53397ff3a1230d24182e5a3079c1e60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53397ff3a1230d24182e5a3079c1e60b">&#9670;&#160;</a></span>getLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int CaBase::getLevel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the OMEX Level of the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object containing <em>this</em> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the OMEX level of this OMEX object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a08020a804325d1c6e33bcf75eb7c035e" title="Returns the Version within the OMEX Level of the CaOmexManifest object containing this object.">getVersion()</a> </dd>
<dd>
<a class="el" href="#af176d8e275582ff993bf6a112739d39d" title="Returns a list of the XML Namespaces declared on the OMEX document owning this object.">getNamespaces()</a> </dd>
<dd>
getPackageVersion() </dd></dl>

</div>
</div>
<a id="a1c85593418e8f234b403e83b46d38696" name="a1c85593418e8f234b403e83b46d38696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c85593418e8f234b403e83b46d38696">&#9670;&#160;</a></span>getLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int CaBase::getLine </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the line number on which this object first appears in the XML representation of the OMEX document, or '0' if the object was created, not read from a file. </p>
<dl class="section return"><dt>Returns</dt><dd>the line number of this OMEX object, or '0' if no such value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The line number for each construct in an OMEX model is set upon reading the model. The accuracy of the line number depends on the correctness of the XML representation of the model, and on the particular XML parser library being used. The former limitation relates to the following problem: if the model is actually invalid XML, then the parser may not be able to interpret the data correctly and consequently may not be able to establish the real line number. The latter limitation is simply that different parsers seem to have their own accuracy limitations, and out of all the parsers supported by libCombine, none have been 100% accurate in all situations. (At this time, libCombine supports the use of <a href="http://xmlsoft.org" target="_blank">libxml2</a>, <a href="http://expat.sourceforge.net/" target="_blank">Expat</a> and <a href="http://xerces.apache.org/xerces-c/" target="_blank">Xerces</a>.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0638886f264d28fe50de399535e2719d" title="Returns the column number on which this object first appears in the XML representation of the OMEX do...">getColumn()</a> </dd></dl>

</div>
</div>
<a id="af0247ac232a6e731bb2a7ffdbad28daa" name="af0247ac232a6e731bb2a7ffdbad28daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0247ac232a6e731bb2a7ffdbad28daa">&#9670;&#160;</a></span>getMetaId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; CaBase::getMetaId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "metaid" attribute of this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the meta-identifier of this OMEX object, as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa322d290c551024384e0e0556c21d414" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set.">isSetMetaId()</a> </dd>
<dd>
<a class="el" href="#a88a8ffa5c220413f3a3f118143471a6a" title="Sets the value of the meta-identifier attribute of this object.">setMetaId(const std::string&amp; metaid)</a> </dd></dl>

</div>
</div>
<a id="a93c5b0b51f1e1b5f293680e7042380ea" name="a93c5b0b51f1e1b5f293680e7042380ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c5b0b51f1e1b5f293680e7042380ea">&#9670;&#160;</a></span>getMetaId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; CaBase::getMetaId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the "metaid" attribute of this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the meta-identifier of this OMEX object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa322d290c551024384e0e0556c21d414" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set.">isSetMetaId()</a> </dd>
<dd>
<a class="el" href="#a88a8ffa5c220413f3a3f118143471a6a" title="Sets the value of the meta-identifier attribute of this object.">setMetaId(const std::string&amp; metaid)</a> </dd></dl>

</div>
</div>
<a id="af176d8e275582ff993bf6a112739d39d" name="af176d8e275582ff993bf6a112739d39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af176d8e275582ff993bf6a112739d39d">&#9670;&#160;</a></span>getNamespaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNamespaces * CaBase::getNamespaces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of the XML Namespaces declared on the OMEX document owning this object. </p>
<p>The <a class="el" href="class_ca_namespaces.html">CaNamespaces</a> object encapsulates OMEX Level/Version/namespaces information. It is used to communicate the OMEX Level, Version, and (in Level&#160;3) packages used in addition to OMEX Level&#160;3 Core.</p>
<dl class="section return"><dt>Returns</dt><dd>the XML Namespaces associated with this OMEX object, or <code>NULL</code> in certain very usual circumstances where a namespace is not set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a53397ff3a1230d24182e5a3079c1e60b" title="Returns the OMEX Level of the CaOmexManifest object containing this object.">getLevel()</a> </dd>
<dd>
<a class="el" href="#a08020a804325d1c6e33bcf75eb7c035e" title="Returns the Version within the OMEX Level of the CaOmexManifest object containing this object.">getVersion()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_ca_omex_manifest.html#a2b7b6ad830f6e9ca691f35c6f29970f3">CaOmexManifest</a>.</p>

</div>
</div>
<a id="a81e3575171d01d305192fe9f3b981efe" name="a81e3575171d01d305192fe9f3b981efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e3575171d01d305192fe9f3b981efe">&#9670;&#160;</a></span>getNamespaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNamespaces * CaBase::getNamespaces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of the XML Namespaces declared on the OMEX document owning this object. </p>
<p>The <a class="el" href="class_ca_namespaces.html">CaNamespaces</a> object encapsulates OMEX Level/Version/namespaces information. It is used to communicate the OMEX Level, Version, and (in Level&#160;3) packages used in addition to OMEX Level&#160;3 Core.</p>
<dl class="section return"><dt>Returns</dt><dd>the XML Namespaces associated with this OMEX object, or <code>NULL</code> in certain very usual circumstances where a namespace is not set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a53397ff3a1230d24182e5a3079c1e60b" title="Returns the OMEX Level of the CaOmexManifest object containing this object.">getLevel()</a> </dd>
<dd>
<a class="el" href="#a08020a804325d1c6e33bcf75eb7c035e" title="Returns the Version within the OMEX Level of the CaOmexManifest object containing this object.">getVersion()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_ca_omex_manifest.html#a54698113a446406b50c20f1676bb145d">CaOmexManifest</a>.</p>

</div>
</div>
<a id="a9269560de6836cad3df7a5ae3a973cc0" name="a9269560de6836cad3df7a5ae3a973cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9269560de6836cad3df7a5ae3a973cc0">&#9670;&#160;</a></span>getNotes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode * CaBase::getNotes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a tree of XMLNode objects. </p>
<p>The "notes" element content returned by this method will be in XML form, but libCombine does not provide an object model specifically for the content of notes. Callers will need to traverse the XML tree structure using the facilities available on XMLNode and related objects. For an alternative method of accessing the notes, see <a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this OMEX object as a tree structure composed of XMLNode objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
setNotes(const std::string&amp; notes) </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="a91b966abd0bb4be17923430dc922156e" name="a91b966abd0bb4be17923430dc922156e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b966abd0bb4be17923430dc922156e">&#9670;&#160;</a></span>getNotes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode * CaBase::getNotes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a tree of XMLNode objects. </p>
<p>The "notes" element content returned by this method will be in XML form, but libCombine does not provide an object model specifically for the content of notes. Callers will need to traverse the XML tree structure using the facilities available on XMLNode and related objects. For an alternative method of accessing the notes, see <a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this OMEX object as a tree structure composed of XMLNode objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
setNotes(const std::string&amp; notes) </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="a23fd5f551aba3eedb06ce605cd95c379" name="a23fd5f551aba3eedb06ce605cd95c379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fd5f551aba3eedb06ce605cd95c379">&#9670;&#160;</a></span>getNotesString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CaBase::getNotesString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a string. </p>
<p>For an alternative method of accessing the notes, see <a class="el" href="#a9269560de6836cad3df7a5ae3a973cc0" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a>, which returns the content as an XMLNode tree structure. Depending on an application's needs, one or the other method may be more convenient.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this OMEX object as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9269560de6836cad3df7a5ae3a973cc0" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
setNotes(const std::string&amp; notes) </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="acbca9496462e61b3413914c273a2fc14" name="acbca9496462e61b3413914c273a2fc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbca9496462e61b3413914c273a2fc14">&#9670;&#160;</a></span>getNotesString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CaBase::getNotesString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a string. </p>
<p>For an alternative method of accessing the notes, see <a class="el" href="#a9269560de6836cad3df7a5ae3a973cc0" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a>, which returns the content as an XMLNode tree structure. Depending on an application's needs, one or the other method may be more convenient.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this OMEX object as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9269560de6836cad3df7a5ae3a973cc0" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
setNotes(const std::string&amp; notes) </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="a6b10f85fbb84bca627e410ada88feb49" name="a6b10f85fbb84bca627e410ada88feb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b10f85fbb84bca627e410ada88feb49">&#9670;&#160;</a></span>getParentCaObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ca_base.html">CaBase</a> * CaBase::getParentCaObject </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parent OMEX object containing this object. </p>
<p>This returns the immediately-containing object. This method is convenient when holding an object nested inside other objects in an OMEX model. <br  />
</p>
<dl class="section return"><dt>Returns</dt><dd>the parent OMEX object of this OMEX object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a421d670badc6d0ad46387852bc8647b2" title="Returns the CaOmexManifest object containing this object instance.">getCaOmexManifest()</a> </dd>
<dd>
getModel() </dd></dl>

</div>
</div>
<a id="a2218615791092a13838e4c1b149b433b" name="a2218615791092a13838e4c1b149b433b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2218615791092a13838e4c1b149b433b">&#9670;&#160;</a></span>getParentCaObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ca_base.html">CaBase</a> * CaBase::getParentCaObject </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parent OMEX object containing this object. </p>
<p>This returns the immediately-containing object. This method is convenient when holding an object nested inside other objects in an OMEX model. <br  />
</p>
<dl class="section return"><dt>Returns</dt><dd>the parent OMEX object of this OMEX object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a421d670badc6d0ad46387852bc8647b2" title="Returns the CaOmexManifest object containing this object instance.">getCaOmexManifest()</a> </dd>
<dd>
getModel() </dd></dl>

</div>
</div>
<a id="a91657399ab98a482e64f9e9d7951aa1b" name="a91657399ab98a482e64f9e9d7951aa1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91657399ab98a482e64f9e9d7951aa1b">&#9670;&#160;</a></span>getTypeCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CaBase::getTypeCode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the libCombine type code for this object.

@copydetails doc_what_are_typecodes

@copydetails doc_additional_typecode_details

@return the @if clike #CaTypeCode_t value@else OMEX object type
code@endif@~ of this OMEX object, or @omexconstant{OMEX_UNKNOWN,
</pre><p> CaTypeCode_t} (the default). The latter is possible because subclasses of <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> are not required to implement this method to return a type code.</p>
<dl class="section see"><dt>See also</dt><dd>getPackageName() </dd>
<dd>
<a class="el" href="#a4587e525d6090ed20433da5d7a568af0" title="Returns the XML element name of this object.">getElementName()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_ca_content.html#ac079a34d06b8b5284da6dad12122615c">CaContent</a>, <a class="el" href="class_ca_cross_ref.html#a07f3b6ea83f3040eac159904ec2cdb5c">CaCrossRef</a>, <a class="el" href="class_ca_list_of.html#a53e543d57cb0591f7b0489bd6637c73f">CaListOf</a>, <a class="el" href="class_ca_list_of_contents.html#aaaed7974396a7c5b0f5b4e037c1d1c7d">CaListOfContents</a>, <a class="el" href="class_ca_list_of_cross_refs.html#a470d8413194de42650f1894394e4f9c8">CaListOfCrossRefs</a>, and <a class="el" href="class_ca_omex_manifest.html#a0f42c30d7801e60b277137fac6a50c3c">CaOmexManifest</a>.</p>

</div>
</div>
<a id="a6c26b51594db9bc5ec9933fbbf874370" name="a6c26b51594db9bc5ec9933fbbf874370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c26b51594db9bc5ec9933fbbf874370">&#9670;&#160;</a></span>getUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CaBase::getUserData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the user data that has been previously set via <a class="el" href="#af1004ed4fc9be13ae92e4819cdda101d" title="Sets the user data of this element.">setUserData()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the user data of this node, or <code>NULL</code> if no user data has been set.</dd></dl>

</div>
</div>
<a id="a08020a804325d1c6e33bcf75eb7c035e" name="a08020a804325d1c6e33bcf75eb7c035e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08020a804325d1c6e33bcf75eb7c035e">&#9670;&#160;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int CaBase::getVersion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Version within the OMEX Level of the <a class="el" href="class_ca_omex_manifest.html" title="@sbmlbrief{combine} TODO:Definition of the CaOmexManifest class.">CaOmexManifest</a> object containing <em>this</em> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the OMEX version of this OMEX object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a53397ff3a1230d24182e5a3079c1e60b" title="Returns the OMEX Level of the CaOmexManifest object containing this object.">getLevel()</a> </dd>
<dd>
<a class="el" href="#af176d8e275582ff993bf6a112739d39d" title="Returns a list of the XML Namespaces declared on the OMEX document owning this object.">getNamespaces()</a> </dd></dl>

</div>
</div>
<a id="a1a4b26e062a2f6cbea2444856e7a9d51" name="a1a4b26e062a2f6cbea2444856e7a9d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4b26e062a2f6cbea2444856e7a9d51">&#9670;&#160;</a></span>hasValidLevelVersionNamespaceCombination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::hasValidLevelVersionNamespaceCombination </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's level/version and namespace values correspond to a valid OMEX specification. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the level, version and namespace values of this OMEX object correspond to a valid set of values, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a6e63a6d1d8b343357064f733fc2c2744" name="a6e63a6d1d8b343357064f733fc2c2744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e63a6d1d8b343357064f733fc2c2744">&#9670;&#160;</a></span>isSetAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::isSetAnnotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "annotation" subelement exists and has content. </p>
<p>Whereas the <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a "annotation" subelement exists, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4b3212ab33366f8cafc2e0fea6964b36" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> </dd>
<dd>
<a class="el" href="#a247f6e7caa0653b648c56c836da2a689" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a078875cee8659966e30707da11ec64cf" name="a078875cee8659966e30707da11ec64cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078875cee8659966e30707da11ec64cf">&#9670;&#160;</a></span>isSetId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CaBase::isSetId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "id" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "id" attribute of this OMEX object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>getId() </dd></dl>

</div>
</div>
<a id="aa322d290c551024384e0e0556c21d414" name="aa322d290c551024384e0e0556c21d414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa322d290c551024384e0e0556c21d414">&#9670;&#160;</a></span>isSetMetaId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::isSetMetaId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "metaid" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "metaid" attribute of this OMEX object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af0247ac232a6e731bb2a7ffdbad28daa" title="Returns the value of the &quot;metaid&quot; attribute of this object.">getMetaId()</a> </dd>
<dd>
<a class="el" href="#a88a8ffa5c220413f3a3f118143471a6a" title="Sets the value of the meta-identifier attribute of this object.">setMetaId(const std::string&amp; metaid)</a> </dd></dl>

</div>
</div>
<a id="aa87ea24600cf7e32fa0739af86eb56de" name="aa87ea24600cf7e32fa0739af86eb56de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87ea24600cf7e32fa0739af86eb56de">&#9670;&#160;</a></span>isSetNotes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::isSetNotes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "notes" subelement exists and has content. </p>
<p>The optional OMEX element named "notes", present on every major OMEX component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libCombine provides the static utility method SyntaxChecker::hasExpectedXHTMLSyntax(  ); however, readers are urged to consult the appropriate <a href="http://omex.org/Documents/Specifications" target="_blank">OMEX specification document</a> for the Level and Version of their model for more in-depth explanations. The OMEX Level&#160;2 and &#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a "notes" subelement exists, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9269560de6836cad3df7a5ae3a973cc0" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects.">getNotes()</a> </dd>
<dd>
<a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
setNotes(const std::string&amp; notes) </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="a5a664853f0c8630587463fc94456355b" name="a5a664853f0c8630587463fc94456355b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a664853f0c8630587463fc94456355b">&#9670;&#160;</a></span>isSetUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::isSetUserData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning true or false depending on whether the user data of this element has been set. </p>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's user data has been set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a90c0195f0460a19feb4a2e2f44a4d7c6" name="a90c0195f0460a19feb4a2e2f44a4d7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c0195f0460a19feb4a2e2f44a4d7c6">&#9670;&#160;</a></span>matchesCaNamespaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::matchesCaNamespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ca_base.html">CaBase</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is the same as <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3f83af6d42623b7c4fbad7454c91f4f9" name="a3f83af6d42623b7c4fbad7454c91f4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f83af6d42623b7c4fbad7454c91f4f9">&#9670;&#160;</a></span>matchesCaNamespaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::matchesCaNamespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ca_base.html">CaBase</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is the same as <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad07ef55d08303ba674b5557b224c5c59" name="ad07ef55d08303ba674b5557b224c5c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07ef55d08303ba674b5557b224c5c59">&#9670;&#160;</a></span>matchesRequiredCaNamespacesForAddition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::matchesRequiredCaNamespacesForAddition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ca_base.html">CaBase</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is a subset of <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0242529fa6143a50316e13c685bebd71" name="a0242529fa6143a50316e13c685bebd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0242529fa6143a50316e13c685bebd71">&#9670;&#160;</a></span>matchesRequiredCaNamespacesForAddition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CaBase::matchesRequiredCaNamespacesForAddition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ca_base.html">CaBase</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is a subset of <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a205124bae0e46b48f83fc26d9f683f0c" name="a205124bae0e46b48f83fc26d9f683f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205124bae0e46b48f83fc26d9f683f0c">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ca_base.html">CaBase</a> &amp; CaBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ca_base.html">CaBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The object whose values are used as the basis of the assignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af08c5ecd035ea5987a676c5c310efdda" name="af08c5ecd035ea5987a676c5c310efdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08c5ecd035ea5987a676c5c310efdda">&#9670;&#160;</a></span>removeFromParentAndDelete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CaBase::removeFromParentAndDelete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes this object from its parent. </p>
<p>If the parent was storing this object as a pointer, it is deleted. If not, it is simply cleared (as in <a class="el" href="class_ca_list_of.html">CaListOf</a> objects). This is a pure virtual method, as every <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> element has different parents, and therefore different methods of removing itself. Will fail (and not delete itself) if it has no parent object. This function is designed to be overridden, but for all objects whose parent is of the class <a class="el" href="class_ca_list_of.html">CaListOf</a>, the default implementation will work.</p>
<ul>
<li>@omexconstant{LIBCOMBINE_OPERATION_SUCCESS, OperationReturnValues_t} </li>
<li>@omexconstant{LIBCOMBINE_OPERATION_FAILED, OperationReturnValues_t} </li>
</ul>

<p>Reimplemented in <a class="el" href="class_ca_list_of.html#a0c12e1aa73888907a2e88197e2dc49bd">CaListOf</a>.</p>

</div>
</div>
<a id="a2e8eeefc12bd14f1e91dfff4bc4ff145" name="a2e8eeefc12bd14f1e91dfff4bc4ff145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8eeefc12bd14f1e91dfff4bc4ff145">&#9670;&#160;</a></span>removeTopLevelAnnotationElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::removeTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>elementName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>elementURI</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the top-level element within the "annotation" subelement of this OMEX object with the given name and optional URI. </p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<p>Calling this method allows a particular annotation element to be removed whilst the remaining annotations remain intact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementName</td><td>a string representing the name of the top level annotation element that is to be removed </td></tr>
    <tr><td class="paramname">elementURI</td><td>an optional string that is used to check both the name and URI of the top level element to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a> </li>
<li><a class="el" href="">LIBCOMBINE_ANNOTATION_NAME_NOT_FOUND </a> </li>
<li><a class="el" href="">LIBCOMBINE_ANNOTATION_NS_NOT_FOUND </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>replaceTopLevelAnnotationElement(const XMLNode *) </dd>
<dd>
<a class="el" href="#a969849ecd6cf03b9900e92f2cf64fd02" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this OMEX object and with ...">replaceTopLevelAnnotationElement(const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a id="aaacc112bb580a4b4c66bda4156ffcc28" name="aaacc112bb580a4b4c66bda4156ffcc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacc112bb580a4b4c66bda4156ffcc28">&#9670;&#160;</a></span>replaceTopLevelAnnotationElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::replaceTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *</td>          <td class="paramname"><span class="paramname"><em>annotation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the given top-level element within the "annotation" subelement of this OMEX object and with the annotation element supplied. </p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<p>This method determines the name of the element to be replaced from the annotation argument. Functionally it is equivalent to calling <code> removeTopLevelAnnotationElement(name); appendAnnotation(annotation_with_name); </code> with the exception that the placement of the annotation element remains the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>XMLNode representing the replacement top level annotation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a> </li>
<li><a class="el" href="">LIBCOMBINE_INVALID_OBJECT </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2e8eeefc12bd14f1e91dfff4bc4ff145" title="Removes the top-level element within the &quot;annotation&quot; subelement of this OMEX object with the given n...">removeTopLevelAnnotationElement(const std::string elementName, const std::string elementURI)</a> </dd>
<dd>
<a class="el" href="#a969849ecd6cf03b9900e92f2cf64fd02" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this OMEX object and with ...">replaceTopLevelAnnotationElement(const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a id="a969849ecd6cf03b9900e92f2cf64fd02" name="a969849ecd6cf03b9900e92f2cf64fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969849ecd6cf03b9900e92f2cf64fd02">&#9670;&#160;</a></span>replaceTopLevelAnnotationElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::replaceTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>annotation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the given top-level element within the "annotation" subelement of this OMEX object and with the annotation element supplied. </p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<p>This method determines the name of the element to be replaced from the annotation argument. Functionally it is equivalent to calling <code> removeTopLevelAnnotationElement(name); appendAnnotation(annotation_with_name); </code> with the exception that the placement of the annotation element remains the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>string representing the replacement top level annotation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a> </li>
<li><a class="el" href="">LIBCOMBINE_INVALID_OBJECT </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2e8eeefc12bd14f1e91dfff4bc4ff145" title="Removes the top-level element within the &quot;annotation&quot; subelement of this OMEX object with the given n...">removeTopLevelAnnotationElement(const std::string elementName, const std::string elementURI)</a> </dd>
<dd>
replaceTopLevelAnnotationElement(const XMLNode*) </dd></dl>

</div>
</div>
<a id="a729235cabf29ab0e203215ddc21e1a34" name="a729235cabf29ab0e203215ddc21e1a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729235cabf29ab0e203215ddc21e1a34">&#9670;&#160;</a></span>setAnnotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CaBase::setAnnotation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>annotation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "annotation" subelement of this OMEX object. </p>
<p>The content of <code>annotation</code> is copied, and any previous content of this object's "annotation" subelement is deleted.</p>
<p>Whereas the <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<p>Call this method will result in any existing content of the "annotation" subelement to be discarded. Unless you have taken steps to first copy and reconstitute any existing annotations into the <code>annotation</code> that is about to be assigned, it is likely that performing such wholesale replacement is unfriendly towards other software applications whose annotations are discarded. An alternative may be to use CaBase::appendAnnotation(const XMLNode* annotation) or <a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">CaBase::appendAnnotation(const std::string&amp; annotation)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML string that is to be used as the content of the "annotation" subelement of this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a247f6e7caa0653b648c56c836da2a689" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="a38ce2b36596260ccc47ea01487e060fd" name="a38ce2b36596260ccc47ea01487e060fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ce2b36596260ccc47ea01487e060fd">&#9670;&#160;</a></span>setAnnotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CaBase::setAnnotation </td>
          <td>(</td>
          <td class="paramtype">LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *</td>          <td class="paramname"><span class="paramname"><em>annotation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "annotation" subelement of this OMEX object. </p>
<p>The content of <code>annotation</code> is copied, and any previous content of this object's "annotation" subelement is deleted.</p>
<p>Whereas the <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<p>Call this method will result in any existing content of the "annotation" subelement to be discarded. Unless you have taken steps to first copy and reconstitute any existing annotations into the <code>annotation</code> that is about to be assigned, it is likely that performing such wholesale replacement is unfriendly towards other software applications whose annotations are discarded. An alternative may be to use CaBase::appendAnnotation(const XMLNode* annotation) or <a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">CaBase::appendAnnotation(const std::string&amp; annotation)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML structure that is to be used as the new content of the "annotation" subelement of this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a247f6e7caa0653b648c56c836da2a689" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="#a465c67ba4ee9c529eba5d5f92e0e26ee" title="Unsets the value of the &quot;annotation&quot; subelement of this OMEX object.">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a id="ae75aefec7e7d0a027beb87d49a1f58cd" name="ae75aefec7e7d0a027beb87d49a1f58cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75aefec7e7d0a027beb87d49a1f58cd">&#9670;&#160;</a></span>setElementText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CaBase::setElementText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When overridden allows <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> elements to use the text included in between the elements tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the text string found between the element tags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2110e7aa28644b6a03a443e3e06c5ea3" name="a2110e7aa28644b6a03a443e3e06c5ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2110e7aa28644b6a03a443e3e06c5ea3">&#9670;&#160;</a></span>setId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CaBase::setId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>sid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "id" attribute of this OMEX object. </p>

</div>
</div>
<a id="a88a8ffa5c220413f3a3f118143471a6a" name="a88a8ffa5c220413f3a3f118143471a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a8ffa5c220413f3a3f118143471a6a">&#9670;&#160;</a></span>setMetaId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::setMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>metaid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the meta-identifier attribute of this object. </p>
<p>The string <code>metaid</code> is copied. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>the identifier string to use as the value of the "metaid" attribute</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>@omexconstant{LIBCOMBINE_OPERATION_SUCCESS, OperationReturnValues_t} </li>
<li>@omexconstant{LIBCOMBINE_INVALID_ATTRIBUTE_VALUE, OperationReturnValues_t} </li>
<li>@omexconstant{LIBCOMBINE_UNEXPECTED_ATTRIBUTE, OperationReturnValues_t}</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af0247ac232a6e731bb2a7ffdbad28daa" title="Returns the value of the &quot;metaid&quot; attribute of this object.">getMetaId()</a> </dd>
<dd>
<a class="el" href="#aa322d290c551024384e0e0556c21d414" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set.">isSetMetaId()</a> </dd></dl>

</div>
</div>
<a id="ad7a7966fa039844b4ea4e2870c72b7a7" name="ad7a7966fa039844b4ea4e2870c72b7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a7966fa039844b4ea4e2870c72b7a7">&#9670;&#160;</a></span>setNamespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::setNamespaces </td>
          <td>(</td>
          <td class="paramtype">LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNamespaces *</td>          <td class="paramname"><span class="paramname"><em>xmlns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the namespaces relevant of this OMEX object. </p>
<p>The content of <code>xmlns</code> is copied, and this object's existing namespace content is deleted.</p>
<p>The <a class="el" href="class_ca_namespaces.html">CaNamespaces</a> object encapsulates OMEX Level/Version/namespaces information. It is used to communicate the OMEX Level, Version, and (in Level&#160;3) packages used in addition to OMEX Level&#160;3 Core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xmlns</td><td>the namespaces to set</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>@omexconstant{LIBCOMBINE_OPERATION_SUCCESS, OperationReturnValues_t} </li>
</ul>

</div>
</div>
<a id="a6caedb0eee6fbd435658dc602d5447f7" name="a6caedb0eee6fbd435658dc602d5447f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caedb0eee6fbd435658dc602d5447f7">&#9670;&#160;</a></span>setNotes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::setNotes </td>
          <td>(</td>
          <td class="paramtype">const LIBSBML_CPP_NAMESPACE_QUALIFIER XMLNode *</td>          <td class="paramname"><span class="paramname"><em>notes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "notes" subelement of this OMEX object. </p>
<p>The content of <code>notes</code> is copied, and any existing content of this object's "notes" subelement is deleted.</p>
<p>The optional OMEX element named "notes", present on every major OMEX component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libCombine provides the static utility method SyntaxChecker::hasExpectedXHTMLSyntax(  ); however, readers are urged to consult the appropriate <a href="http://omex.org/Documents/Specifications" target="_blank">OMEX specification document</a> for the Level and Version of their model for more in-depth explanations. The OMEX Level&#160;2 and &#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML structure that is to be used as the content of the "notes" subelement of this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_INVALID_OBJECT </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
<a class="el" href="#a9ab84560444f3a86bd309fe3b3254224" title="Sets the value of the &quot;notes&quot; subelement of this OMEX object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="a9ab84560444f3a86bd309fe3b3254224" name="a9ab84560444f3a86bd309fe3b3254224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab84560444f3a86bd309fe3b3254224">&#9670;&#160;</a></span>setNotes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::setNotes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>notes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>addXHTMLMarkup</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the "notes" subelement of this OMEX object to a copy of the string <code>notes</code>. </p>
<p>The content of <code>notes</code> is copied, and any existing content of this object's "notes" subelement is deleted.</p>
<p>The optional OMEX element named "notes", present on every major OMEX component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libCombine provides the static utility method SyntaxChecker::hasExpectedXHTMLSyntax(  ); however, readers are urged to consult the appropriate <a href="http://omex.org/Documents/Specifications" target="_blank">OMEX specification document</a> for the Level and Version of their model for more in-depth explanations. The OMEX Level&#160;2 and &#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML string that is to be used as the content of the "notes" subelement of this object</td></tr>
    <tr><td class="paramname">addXHTMLMarkup</td><td>a boolean indicating whether to wrap the contents of the <code>notes</code> argument with XHTML paragraph (<code>&lt;p&gt;</code>) tags. This is appropriate when the string in <code>notes</code> does not already containg the appropriate XHTML markup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a> </li>
<li><a class="el" href="">LIBCOMBINE_INVALID_OBJECT </a> </li>
<li><a class="el" href="">LIBCOMBINE_OPERATION_FAILED </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="#abb468af2b83715d94f2be01c45d0183a" title="Unsets the value of the &quot;notes&quot; subelement of this OMEX object.">unsetNotes()</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="af1004ed4fc9be13ae92e4819cdda101d" name="af1004ed4fc9be13ae92e4819cdda101d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1004ed4fc9be13ae92e4819cdda101d">&#9670;&#160;</a></span>setUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::setUserData </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>userData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the user data of this element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>specifies the new user data.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>@omexconstant{LIBCOMBINE_OPERATION_SUCCESS, OperationReturnValues_t} </li>
<li>@omexconstant{LIBCOMBINE_OPERATION_FAILED, OperationReturnValues_t} </li>
</ul>

</div>
</div>
<a id="a7b933a9ea9648f9246f0691b36a0f948" name="a7b933a9ea9648f9246f0691b36a0f948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b933a9ea9648f9246f0691b36a0f948">&#9670;&#160;</a></span>toCa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CaBase::toCa </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string consisting of a partial OMEX corresponding to just this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the partial OMEX that describes this OMEX object.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">This is primarily provided for testing and debugging purposes. It may be removed in a future version of libCombine.</span> </dd></dl>

</div>
</div>
<a id="a465c67ba4ee9c529eba5d5f92e0e26ee" name="a465c67ba4ee9c529eba5d5f92e0e26ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465c67ba4ee9c529eba5d5f92e0e26ee">&#9670;&#160;</a></span>unsetAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::unsetAnnotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "annotation" subelement of this OMEX object. </p>
<p>Whereas the <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>OMEX places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the OMEX specifications for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4b3212ab33366f8cafc2e0fea6964b36" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects.">getAnnotation()</a> </dd>
<dd>
<a class="el" href="#a247f6e7caa0653b648c56c836da2a689" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string.">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="#a6e63a6d1d8b343357064f733fc2c2744" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content.">isSetAnnotation()</a> </dd>
<dd>
setAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a729235cabf29ab0e203215ddc21e1a34" title="Sets the value of the &quot;annotation&quot; subelement of this OMEX object.">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
appendAnnotation(const XMLNode* annotation) </dd>
<dd>
<a class="el" href="#a9b188422dafe049c6a611c515f18ce2f" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object.">appendAnnotation(const std::string&amp; annotation)</a> </dd></dl>

</div>
</div>
<a id="abc7c7b5927871ffcd287100f3b497364" name="abc7c7b5927871ffcd287100f3b497364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7c7b5927871ffcd287100f3b497364">&#9670;&#160;</a></span>unsetId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int CaBase::unsetId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "id" attribute of this OMEX object. </p>

</div>
</div>
<a id="ae71a8df29221b441acb3f38290e2396d" name="ae71a8df29221b441acb3f38290e2396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71a8df29221b441acb3f38290e2396d">&#9670;&#160;</a></span>unsetMetaId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::unsetMetaId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "metaid" attribute of this OMEX object. </p>

</div>
</div>
<a id="abb468af2b83715d94f2be01c45d0183a" name="abb468af2b83715d94f2be01c45d0183a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb468af2b83715d94f2be01c45d0183a">&#9670;&#160;</a></span>unsetNotes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::unsetNotes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the value of the "notes" subelement of this OMEX object. </p>
<p>The optional OMEX element named "notes", present on every major OMEX component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_ca_base.html" title="@sbmlbrief{} TODO:Definition of the CaBase class.">CaBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libCombine provides the static utility method SyntaxChecker::hasExpectedXHTMLSyntax(  ); however, readers are urged to consult the appropriate <a href="http://omex.org/Documents/Specifications" target="_blank">OMEX specification document</a> for the Level and Version of their model for more in-depth explanations. The OMEX Level&#160;2 and &#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The possible values returned by this function are: <ul>
<li><a class="el" href="">LIBCOMBINE_OPERATION_SUCCESS </a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23fd5f551aba3eedb06ce605cd95c379" title="Returns the content of the &quot;notes&quot; subelement of this object as a string.">getNotesString()</a> </dd>
<dd>
<a class="el" href="#aa87ea24600cf7e32fa0739af86eb56de" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content.">isSetNotes()</a> </dd>
<dd>
setNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#a9ab84560444f3a86bd309fe3b3254224" title="Sets the value of the &quot;notes&quot; subelement of this OMEX object to a copy of the string notes.">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
appendNotes(const XMLNode* notes) </dd>
<dd>
<a class="el" href="#ac9d4c09ed628b621fe6e6beaf03d6e97" title="Appends the given notes to the &quot;notes&quot; subelement of this object.">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
SyntaxChecker::hasExpectedXHTMLSyntax(  ) </dd></dl>

</div>
</div>
<a id="a625227a7c609828531f0151545c46cf6" name="a625227a7c609828531f0151545c46cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625227a7c609828531f0151545c46cf6">&#9670;&#160;</a></span>unsetUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CaBase::unsetUserData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the user data of this element. </p>
<ul>
<li>@omexconstant{LIBCOMBINE_OPERATION_SUCCESS, OperationReturnValues_t} </li>
<li>@omexconstant{LIBCOMBINE_OPERATION_FAILED, OperationReturnValues_t} </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_ca_base.html">CaBase</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
